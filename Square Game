#Author: Jared Greiner
#Date:   7/3/2019
#Purpose: Simple game where the player must dodge blocks falling from the sky. The move blocks the player dodges teh higher their score. As the score increases so does the difficulty.
#Improvements: Function that sends the player to the other side of the field if they go too far right or left(like Pacman). function to create a ceiling and floor.

import pygame
import sys
import random
import math

pygame.init()

WIDTH = 600
HEIGHT = 700
SCORE_CLR = (0,0,0)

player_pos = [WIDTH/2, HEIGHT/1.2]
enemy_pos = [WIDTH/2,0]
block_list = [enemy_pos]
block_size = 30
move_dist = 30

score = 0
fall_spd = 10
game_over = False

clock = pygame.time.Clock()
score_font = pygame.font.SysFont("monospace", 35)
screen = pygame.display.set_mode((WIDTH,HEIGHT))


def create_blocks(player_pos,block_list,screen,block_size):

	delay = random.random()
	player_clr = (255,0,0)
	enemy_clr = (0,0,255)
	
	pygame.draw.rect(screen,(player_clr),(player_pos[0], player_pos[1], block_size, block_size))
	
	spawn_points = list(range(30,601,30))
	

	if len(block_list) <= 15 and delay < 0.3:
		x_pos = random.choice(spawn_points)
		y_pos = 1
		enemy_pos = [x_pos,y_pos]
		block_list.append(enemy_pos)

	for enemy_pos in block_list:
		pygame.draw.rect(screen,(enemy_clr),(enemy_pos[0],enemy_pos[1],block_size,block_size))
		
		
def falling_blocks(block_list,score,fall_spd):

	for i, enemy_pos in enumerate(block_list):

		if enemy_pos[1] >= 0 and enemy_pos[1] < HEIGHT:
			enemy_pos[1] += fall_spd
		else:
			block_list.pop(i)
			score += 1
		
	return score


def draw_lines(WIDTH,HEIGHT,screen):

	rows = 20
	size_betwn = WIDTH // rows
	x = 0
	y = 0

	create_blocks(player_pos,block_list,screen,block_size)

	pygame.draw.line(screen, (0,0,0), (0,612), (WIDTH,612))
	pygame.draw.line(screen, (0,0,0), (0,0), (WIDTH,x))

	for line in range(rows):
		x = x + size_betwn
		y = y + size_betwn

		pygame.draw.line(screen, (0,0,0), (y,0), (y,612))

def game_window():
	
	screen.fill((0,255,255))
	draw_lines(WIDTH,HEIGHT,screen)
	text = "Score: " + str(score)
	label = score_font.render(text,1, (0,0,0))
	screen.blit(label, (WIDTH - 250, HEIGHT - 50))
	pygame.display.update()
	
	
def difficulty(score,fall_spd):
	if score < 50:
		fall_spd = 10
	elif score < 150:
		fall_spd = score / 5
	else:
		fall_spd = 150 / 5
	return fall_spd

def collision_check(block_list,player_pos,block_size):


	p_x = player_pos[0]
	p_y = player_pos[1]

	for enemy_pos in block_list:
		
		e_x = enemy_pos[0]
		e_y = enemy_pos[1]

		if p_x >= e_x and p_x < (e_x + block_size) or e_x >= p_x and e_x < (p_x + block_size):
			if p_y >= e_y and p_y < (e_y + block_size) or e_y >= p_y and e_y < (p_y + block_size):

				return True
	 

def collision_resolution(block_list,player_pos,block_size):
	for enemy_pos in enumerate(block_list):
		if collision_check(block_list,player_pos,block_size):
			return True
	return False
			
		
	

while not game_over:
	for event in pygame.event.get():

		if event.type == pygame.QUIT:
			sys.exit()
		if event.type == pygame.KEYDOWN:

			x = player_pos[0]
			y = player_pos[1]

			if event.key == pygame.K_LEFT:
				x -= move_dist
			elif event.key == pygame.K_RIGHT:
				x += move_dist
			elif event.key == pygame.K_UP:
				y -= move_dist
			elif event.key == pygame.K_DOWN:
				y += move_dist

			player_pos = [x,y]

	game_window()
	score = falling_blocks(block_list, score, fall_spd)
	fall_spd = difficulty(score, fall_spd)

	if collision_resolution(block_list,player_pos,block_size):

		game_over = True
			
	clock.tick(30)
